% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/partialize.R
\name{partialize}
\alias{partialize}
\title{Partialize Data}
\usage{
partialize(data, x, y, include_factors = TRUE, multilevel = FALSE,
  bayesian = FALSE)
}
\arguments{
\item{data}{A dataframe.}

\item{x}{Names of two variables present in the data.}

\item{y}{Names of two variables present in the data.}

\item{include_factors}{If \code{TRUE}, the factors are kept and eventually converted to numeric or used as random effects (depending of \code{random}). If \code{FALSE}, factors are removed upfront.}

\item{multilevel}{If \code{TRUE}, the factors are included as random factors. If \code{FALSE} (default), factors are binarized (dummified) and partialized out in the same than the other numeric variables.}

\item{bayesian}{If TRUE, will run a Bayesian correlation. Note that for "full" Bayesian partial correlations, you will also need to set \code{partial_bayesian} to \code{TRUE}. Otherwise, you will obtain pseudo-Bayesian partial correlations (i.e., Bayesian correlation based on frequentist partialization).}
}
\description{
This function can be used to (slowly) get the data of which a regular correlation is equivalent to the partial correlation between two variables (adjusted for the rest of the dataset). As it is based on underlying fitting of multiple regressions, it allows more flexibility, such as including factors as random effects and/or fitting the models under a Bayesian framework. The values returned by this function are the residuals of the regression models.
}
\examples{
pcordata <- partialize(
  data = iris[1:4],
  x = "Sepal.Length",
  y = "Sepal.Width"
)
cor(pcordata)

# Is equivalent to
cor_to_pcor(cor(iris[1:4]))[1:2, 1:2]
\donttest{
# Which is close the the Bayesian alternative
pcordata <- partialize(
  data = iris[1:4],
  x = "Sepal.Length",
  y = "Sepal.Width",
  bayesian = TRUE
)
cor(pcordata)
}

}
